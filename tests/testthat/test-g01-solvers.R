context("test-g01-solvers")
TOL <- 1e-6

a <- Variable(name = "a")
b <- Variable(name = "b")
c <- Variable(name = "c")

x <- Variable(2, name = "x")
y <- Variable(3, name = "y")
z <- Variable(2, name = "z")

A <- Variable(2, 2, name = "A")
B <- Variable(2, 2, name = "B")
C <- Variable(3, 2, name = "C")

SOLVER_MAP_CONIC <- CVXR:::SOLVER_MAP_CONIC
SOLVER_MAP_QP <- CVXR:::SOLVER_MAP_QP
INSTALLED_SOLVERS <- CVXR:::INSTALLED_SOLVERS

test_that("Test that all the ECOS solver options work", {
  # Test ecos
  # feastol, abstol, reltol, feastol_inacc,
  # abstol_inacc, and reltol_inacc for tolerance values
  # max_iters for the maximum number of iterations,
  EPS <- 1e-4
  prob <- Problem(Minimize(p_norm(x,1) + 1.0), list(x == 0))
  for(i in 1:2) {
    result <- solve(prob, solver = "ECOS", feastol = EPS, abstol = EPS, reltol = EPS, 
                    feastol_inacc = EPS, abstol_inacc = EPS, reltol_inacc = EPS, 
                    max_iters = 20, verbose = TRUE, warm_start = TRUE)
  }
  expect_equal(result$value, 1.0, tolerance = TOL)
  expect_equal(result$getValue(x), as.matrix(c(0, 0)), tolerance = TOL)
})

test_that("Test that all the ECOS BB solver options work", {
  # 'mi_maxiter'
  # maximum number of branch and bound iterations (default: 1000)
  # 'mi_abs_eps'
  # absolute tolerance between upper and lower bounds (default: 1e-6)
  # 'mi_rel_eps'
  prob <- Problem(Minimize(p_norm(x,1) + 1.0), list(x == Variable(2, boolean = TRUE)))
  for(i in 1:2) {
    result <- solve(prob, solver = "ECOS_BB", mi_max_iters = 100, mi_abs_eps = 1e-6,
                    mi_rel_eps = 1e-5, verbose = TRUE, warm_start = TRUE)
  }
  expect_equal(result$value, 1.0, tolerance = TOL)
  expect_equal(result$getValue(x), as.matrix(c(0, 0)), tolerance = TOL)
})

test_that("Test that all the SCS solver options work", {
  # Test SCS
  # MAX_ITERS, EPS, ALPHA, UNDET_TOL, VERBOSE, and NORMALIZE.
  # If opts is missing, then the algorithm uses default settings.
  # USE_INDIRECT = True
  EPS <- 1e-4
  prob <- Problem(Minimize(p_norm(x,1) + 1.0), list(x == 0))
  for(i in 1:2) {
    result <- solve(prob, solver = "SCS", max_iters = 50, eps = EPS, alpha = EPS,
                    verbose = TRUE, normalize = TRUE, use_indirect = FALSE)
  }
  expect_equal(result$value, 1.0, tolerance = 1e-2)
  expect_equal(result$getValue(x), as.matrix(c(0, 0)), tolerance = 1e-2)
})

# test_that("Test that all the CVXOPT solver options work", {
#   if("CVXOPT" %in% installed_solvers()) {
#     EPS <- 1e-7
#     for(i in 1:2) {
#       result <- solve(prob, solver = "CVXOPT", feastol = EPS, abstol = EPS, reltol = EPS,
#                       max_iters = 20, verbose = TRUE, kktsolver = "chol", refinement = 2, warm_start = TRUE)
#     }
#     expect_equal(result$value, 1.0, tolerance = TOL)
#     expect_equal(result$getValue(x), matrix(c(0, 0)), tolerance = TOL)
#   }
# })

test_that("Test a basic LP with GLPK", {
  # Either the problem is solved or GLPK is not installed.
  if("GLPK" %in% installed_solvers()) {
    prob <- Problem(Minimize(p_norm(x, 1) + 1.0), list(x == 0))
    result <- solve(prob, solver = "GLPK")
    expect_equal(result$value, 1.0, tolerance = TOL)
    expect_equal(result$getValue(x), matrix(c(0, 0)), tolerance = TOL)
    
    # Example from
    # http://cvxopt.org/userguide/coneprog.html?highlight=solvers.lp#cvxopt.solvers.lp
    objective <- Minimize(-4*x[1] - 5*x[2])
    constraints <- list(2*x[1] + x[2] <= 3, 
                        x[1] + 2*x[2] <= 3,
                        x[1] >= 0,
                        x[2] >= 0)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "GLPK")
    expect_equal(result$value, -9, tolerance = TOL)
    expect_equal(result$getValue(x), matrix(c(1, 1)), tolerance = TOL)
  } else {
    prob <- Problem(Minimize(p_norm(x, 1) + 1.0), list(x == 0))
    expect_error(result <- solve(prob, solver = "GLPK"), "The solver GLPK is not installed")
  }
})

test_that("Test a basic MILP with GLPK", {
  # Either the problem is solved or GLPK is not installed.
  if("GLPK_MI" %in% installed_solvers()) {
    bool_var <- Variable(boolean = TRUE)
    int_var <- Variable(integer = TRUE)
    prob <- Problem(Minimize(p_norm(x, 1) + 1.0), list(x == bool_var, bool_var == 0))
    result <- solve(prob, solver = "GLPK_MI", verbose = TRUE)
    expect_equal(result$value, 1.0, tolerance = TOL)
    expect_equal(result$getValue(bool_var), 0, tolerance = TOL)
    expect_equal(result$getValue(x), matrix(c(0, 0)), tolerance = TOL)
    
    # Example from
    # http://cvxopt.org/userguide/coneprog.html?highlight=solvers.lp#cvxopt.solvers.lp
    objective <- Minimize(-4*x[1] - 5*x[2])
    constraints <- list(2*x[1] + x[2] <= int_var,
                        x[1] + 2*x[2] <= 3*bool_var,
                        x[1] >= 0,
                        x[2] >= 0,
                        int_var == 3*bool_var,
                        int_var == 3)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "GLPK_MI", verbose = TRUE)
    expect_equal(result$value, -9, tolerance = TOL)
    expect_equal(result$getValue(int_var), 3, tolerance = TOL)
    expect_equal(result$getValue(bool_var), 1, tolerance = TOL)
    expect_equal(result$getValue(x), matrix(c(1, 1)), tolerance = TOL)
  } else {
    prob <- Problem(Minimize(p_norm(x, 1) + 1.0), list(x == 0))
    expect_error(result <- solve(prob, solver = "GLPK_MI"), "The solver GLPK_MI is not installed")
  }
})

test_that("Test a basic LP with CPLEX", {
  if("CPLEX" %in% installed_solvers()) {
    prob <- Problem(Minimize(p_norm(x,1) + 1.0), list(x == 0))
    debugonce(solve, signature = c("CPLEX_CONIC"))
    result <- solve(prob, solver = "CPLEX")
    expect_equal(result$value, 1.0, tolerance = TOL)
    expect_equal(result$getValue(x), as.matrix(c(0, 0)), tolerance = TOL)
    
    # Example from
    # http://cvxopt.org/userguide/coneprog.html?highlight=solvers.lp#cvxopt.solvers.lp
    objective <- Minimize(-4*x[1] - 5*x[2])
    constraints <- list(2*x[1] + x[2] <= 3, x[1] + 2*x[2] <= 3, x[1] >= 0, x[2] >= 0)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "CPLEX")
    expect_equal(result$value, -9, tolerance = TOL)
    expect_equal(result$getValue(x), as.matrix(c(1, 1)), tolerance = TOL)
    
    # CPLEX's default lower bound for a decision variable is zero
    # This quick test ensures that the cvxpy interface for CPLEX does *not* have that bound
    objective <- Minimize(x[1])
    constraints <- list(x[1] >= -100, x[1] <= -10, x[2] == 1)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "CPLEX")
    expect_equal(result$getValue(x), as.matrix(c(-100, 1)), tolerance = TOL)
    
    # Boolean and integer version.
    bool_var <- Variable(boolean = TRUE)
    int_var <- Variable(integer = TRUE)
    prob <- Problem(Minimize(p_norm(x,1)), list(x == bool_var, bool_var == 0))
    result <- solve(prob, solver = "CPLEX")
    expect_equal(result$value, 0, tolerance = TOL)
    expect_equal(result$getValue(bool_var), 0, tolerance = TOL)
    expect_equal(result$getValue(x), as.matrix(c(0, 0)), tolerance = TOL)
    
    # Example from
    # http://cvxopt.org/userguide/coneprog.html?highlight=solvers.lp#cvxopt.solvers.lp
    objective <- Minimize(-4*x[1] - 5*x[2])
    constraints <- list(2*x[1] + x[2] <= int_var, x[1] + 2*x[2] <= 3*bool_var, x[1] >= 0, x[2] >= 0, int_var == 3*bool_var, int_var == 3)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "CPLEX")
    expect_equal(result$value, -9, tolerance = TOL)
    expect_equal(result$getValue(int_var), 3, tolerance = TOL)
    expect_equal(result$getValue(bool_var), 1, tolerance = TOL)
    expect_equal(result$getValue(x), as.matrix(c(1,1)), tolerance = TOL)
  } else {
    prob <- Problem(Minimize(p_norm(x,1)), list(x == 0))
    expect_error(result <- solve(prob, solver = "CPLEX"), "The solver CPLEX is not installed")
  }
})

test_that("Test a basic SOCP with CPLEX", {
  if("CPLEX" %in% installed_solvers()) {
    prob <- Problem(Minimize(p_norm(x,2) + 1.0), list(x == 0))
    browser()
    result <- solve(prob, solver = "CPLEX")
    expect_equal(result$value, 1.0, tolerance = TOL)
    expect_equal(result$getValue(x), as.matrix(c(0, 0)), tolerance = TOL)
    
    # Example from
    # http://cvxopt.org/userguide/coneprog.html?highlight=solvers.lp#cvxopt.solvers.lp
    objective <- Minimize(-4*x[1] - 5*x[2])
    constraints <- list(2*x[1] + x[2] <= 3, (x[1] + 2*x[2])^2 <= 9, x[1] >= 0, x[2] >= 0)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "CPLEX")
    expect_equal(result$value, -9, tolerance = TOL)
    expect_equal(result$getValue(x), as.matrix(c(1, 1)), tolerance = TOL)
    
    # CPLEX's default lower bound for a decision variable is zero
    # This quick test ensures that the CVXR interface for CPLEX does *not* have that bound
    objective <- Minimize(x[1])
    constraints <- list(x[1] >= -100, x[1] <= -10, x[2] == 1)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "CPLEX")
    expect_equal(result$getValue(x), as.matrix(c(-100, 1)), tolerance = TOL)
    
    # Boolean and integer version.
    bool_var <- Variable(boolean = TRUE)
    int_var <- Variable(integer = TRUE)
    prob <- Problem(Minimize(p_norm(x,2)), list(x == bool_var, bool_var == 0))
    result <- solve(prob, solver = "CPLEX")
    expect_equal(result$value, 0, tolerance = TOL)
    expect_equal(result$getValue(bool_var), 0, tolerance = TOL)
    expect_equal(result$getValue(x), as.matrix(c(0, 0)), tolerance = TOL)
    
    # Example from
    # http://cvxopt.org/userguide/coneprog.html?highlight=solvers.lp#cvxopt.solvers.lp
    objective <- Minimize(-4*x[1] - 5*x[2])
    constraints <- list(2*x[1] + x[2] <= int_var, (x[1] + 2*x[2])^2 <= 9*bool_var, x[1] >= 0, x[2] >= 0, int_var == 3*bool_var, int_var == 3)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "CPLEX")
    expect_equal(result$value, -9, tolerance = TOL)
    expect_equal(result$getValue(int_var), 3, tolerance = TOL)
    expect_equal(result$getValue(bool_var), 1, tolerance = TOL)
    expect_equal(result$getValue(x), as.matrix(c(1,1)), tolerance = TOL)
  } else {
    prob <- Problem(Minimize(p_norm(x,1)), list(x == 0))
    expect_error(result <- solve(prob, solver = "CPLEX"), "The solver CPLEX is not installed")
  }
})

test_that("Make sure CPLEX's dual result matches other solvers", {
  if("CPLEX" %in% installed_solvers()) {
    constraints <- list(x == 0)
    prob <- Problem(Minimize(p_norm(x,1)))
    result <- solve(prob, solver = "CPLEX")
    duals_gurobi <- lapply(constraints, function(c) { result$getDualValue(c) })
    result <- solve(prob, solver = "ECOS")
    duals_ecos <- lapply(constraints, function(c) { result$getDualValue(c) })
    for(i in seq_along(constraints))
      expect_equal(duals_gurobi[[i]], duals_ecos[[i]], tolerance = TOL)
    
    # Example from
    # http://cvxopt.org/userguide/coneprog.html?highlight=solvers.lp#cvxopt.solvers.lp
    objective <- Minimize(-4*x[1] - 5*x[2])
    constraints <- list(2*x[1] + x[2] <= 3, x[1] + 2*x[2] <= 3, x[1] >= 0, x[2] >= 0)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "CPLEX")
    duals_gurobi <- lapply(constraints, function(c) { result$getDualValue(c) })
    result <- solve(prob, solver = "ECOS")
    duals_ecos <- lapply(constraints, function(c) { result$getDualValue(c) })
    for(i in seq_along(constraints))
      expect_equal(duals_gurobi[[i]], duals_ecos[[i]], tolerance = TOL)
  } else {
    prob <- Problem(Minimize(p_norm(x,1)), list(x == 0))
    expect_error(result <- solve(prob, solver = "CPLEX"), "The solver CPLEX is not installed")
  }
})

test_that("Test CPLEX warm start", {
  # Make sure that warm starting CPLEX behaves as expected.
  # Note: This only checks output, not whether or not CPLEX is warm starting internally.
  if("CPLEX" %in% installed_solvers()) {
    A <- Parameter(2, 2)
    b <- Parameter(2)
    h <- Parameter(2)
    c <- Parameter(2)
    
    value(A) <- rbind(c(1,0), c(0,0))
    value(b) <- c(1,0)
    value(h) <- c(2,2)
    value(c) <- c(1,1)
    
    objective <- Maximize(c[1]*x[1] + c[2]*x[2])
    constraints <- list(x[1] <= h[1],
                        x[2] <= h[2],
                        A %*% x == b)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "CPLEX", warm_start = TRUE)
    expect_equal(result$value, 3)
    expect_equal(result$getValue(x), matrix(c(1, 2)), tolerance = TOL)
    
    # Change A and b from the original values.
    value(A) <- rbind(c(0,0), c(0,1))   # <----- Changed.
    value(b) <- c(0,1)   # <----- Changed.
    value(h) <- c(2,2)
    value(c) <- c(1,1)
    
    # Without setting update_eq_constrs = FALSE, the results should change to the correct answer.
    objective <- Maximize(c[1]*x[1] + c[2]*x[2])
    constraints <- list(x[1] <= h[1],
                        x[2] <= h[2],
                        A %*% x == b)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "CPLEX", warm_start = TRUE)
    expect_equal(result$value, 3)
    expect_equal(result$getValue(x), matrix(c(2, 1)), tolerance = TOL)
    
    # Change h from the original values.
    value(A) <- rbind(c(1,0), c(0,0))
    value(b) <- c(1,0)
    value(h) <- c(1,1)   # <----- Changed.
    value(c) <- c(1,1)
    
    # Without setting update_eq_constrs = FALSE, the results should change to the correct answer.
    objective <- Maximize(c[1]*x[1] + c[2]*x[2])
    constraints <- list(x[1] <= h[1],
                        x[2] <= h[2],
                        A %*% x == b)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "CPLEX", warm_start = TRUE)
    expect_equal(result$value, 2)
    expect_equal(result$getValue(x), matrix(c(1, 1)), tolerance = TOL)
    
    # Change c from the original values.
    value(A) <- rbind(c(1,0), c(0,0))
    value(b) <- c(1,0)
    value(h) <- c(2,2)
    value(c) <- c(2,1)   # <----- Changed.
    
    # Without setting update_eq_constrs = FALSE, the results should change to the correct answer.
    objective <- Maximize(c[1]*x[1] + c[2]*x[2])
    constraints <- list(x[1] <= h[1],
                        x[2] <= h[2],
                        A %*% x == b)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "CPLEX", warm_start = TRUE)
    expect_equal(result$value, 4)
    expect_equal(result$getValue(x), matrix(c(1, 2)), tolerance = TOL)
  } else {
    prob <- Problem(Minimize(p_norm(x, 1) + 1.0), list(x == 0))
    expect_error(result <- solve(prob, solver = "CPLEX", warm_start = TRUE), "The solver CPLEX is not installed")
  }
})

test_that("Test CPLEX parameters", {
  if("CPLEX" %in% installed_solvers()) {
    n <- 10
    m <- 4
    A <- matrix(rnorm(m*n), nrow = m, ncol = n)
    x <- matrix(rnorm(n), nrow = n, ncol = 1)
    y <- A %*% x
    
    # Solve a simple basis pursuit problem for testing purposes.
    z <- Variable(n)
    objective <- Minimize(norm1(z))
    constraints <- list(A %*% z == y)
    problem <- Problem(objective, constraints)
    expect_error(result <- solve(problem, solver = "CPLEX", bogus = "foo"))
    expect_error(result <- solve(problem, solver = "CPLEX", invalid_kwarg = NA))
    # solve(problem, solver = "CPLEX", advance = 0, simplex.limits.iterations = 1000, timelimit = 1000.0, workdir = "mydir")
  } else {
    n <- 10
    m <- 4
    A <- matrix(rnorm(m*n), nrow = m, ncol = n)
    x <- matrix(rnorm(n), nrow = n, ncol = 1)
    y <- A %*% x
    
    # Solve a simple basis pursuit problem for testing purposes.
    z <- Variable(n)
    objective <- Minimize(norm1(z))
    constraints <- list(A %*% z == y)
    problem <- Problem(objective, constraints)
    expect_error(result <- solve(problem, solver = "CPLEX"), "The solver CPLEX is not installed")
  }
})

test_that("Make sure CVXOPT's dual result matches other solvers", {
  if("CVXOPT" %in% installed_solvers()) {
    constraints <- list(x == 0)
    prob <- Problem(Minimize(p_norm(x,1)))
    result <- solve(prob, solver = "CVXOPT")
    duals_gurobi <- lapply(constraints, function(c) { result$getDualValue(c) })
    result <- solve(prob, solver = "ECOS")
    duals_ecos <- lapply(constraints, function(c) { result$getDualValue(c) })
    for(i in seq_along(constraints))
      expect_equal(duals_gurobi[[i]], duals_ecos[[i]], tolerance = TOL)
    
    # Example from
    # http://cvxopt.org/userguide/coneprog.html?highlight=solvers.lp#cvxopt.solvers.lp
    objective <- Minimize(-4*x[1] - 5*x[2])
    constraints <- list(2*x[1] + x[2] <= 3, x[1] + 2*x[2] <= 3, x[1] >= 0, x[2] >= 0)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "CVXOPT")
    duals_gurobi <- lapply(constraints, function(c) { result$getDualValue(c) })
    result <- solve(prob, solver = "ECOS")
    duals_ecos <- lapply(constraints, function(c) { result$getDualValue(c) })
    for(i in seq_along(constraints))
      expect_equal(duals_gurobi[[i]], duals_ecos[[i]], tolerance = TOL)
  } else {
    prob <- Problem(Minimize(p_norm(x,1)), list(x == 0))
    expect_error(result <- solve(prob, solver = "CVXOPT"), "The solver CVXOPT is not installed")
  }
})

test_that("Test a basic LP with GUROBI", {
  if("GUROBI" %in% installed_solvers()) {
    prob <- Problem(Minimize(p_norm(x,1) + 1.0), list(x == 0))
    result <- solve(prob, solver = "GUROBI")
    expect_equal(result$value, 1.0, tolerance = TOL)
    expect_equal(result$getValue(x), as.matrix(c(0, 0)), tolerance = TOL)
    
    # Example from
    # http://cvxopt.org/userguide/coneprog.html?highlight=solvers.lp#cvxopt.solvers.lp
    objective <- Minimize(-4*x[1] - 5*x[2])
    constraints <- list(2*x[1] + x[2] <= 3, x[1] + 2*x[2] <= 3, x[1] >= 0, x[2] >= 0)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "GUROBI")
    expect_equal(result$value, -9, tolerance = TOL)
    expect_equal(result$getValue(x), as.matrix(c(1, 1)), tolerance = TOL)
    
    # GUROBI's default lower bound for a decision variable is zero
    # This quick test ensures that the cvxpy interface for GUROBI does *not* have that bound
    objective <- Minimize(x[1])
    constraints <- list(x[1] >= -100, x[1] <= -10, x[2] == 1)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "GUROBI")
    expect_equal(result$getValue(x), as.matrix(c(-100, 1)), tolerance = TOL)
    
    # Boolean and integer version.
    bool_var <- Variable(boolean = TRUE)
    int_var <- Variable(integer = TRUE)
    prob <- Problem(Minimize(p_norm(x,1)), list(x == bool_var, bool_var == 0))
    result <- solve(prob, solver = "GUROBI")
    expect_equal(result$value, 0, tolerance = TOL)
    expect_equal(result$getValue(bool_var), 0, tolerance = TOL)
    expect_equal(result$getValue(x), as.matrix(c(0, 0)), tolerance = TOL)
    
    # Example from
    # http://cvxopt.org/userguide/coneprog.html?highlight=solvers.lp#cvxopt.solvers.lp
    objective <- Minimize(-4*x[1] - 5*x[2])
    constraints <- list(2*x[1] + x[2] <= int_var, x[1] + 2*x[2] <= 3*bool_var, x[1] >= 0, x[2] >= 0, int_var == 3*bool_var, int_var == 3)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "GUROBI")
    expect_equal(result$value, -9, tolerance = TOL)
    expect_equal(result$getValue(int_var), 3, tolerance = TOL)
    expect_equal(result$getValue(bool_var), 1, tolerance = TOL)
    expect_equal(result$getValue(x), as.matrix(c(1,1)), tolerance = TOL)
  } else {
    prob <- Problem(Minimize(p_norm(x,1)), list(x == 0))
    expect_error(result <- solve(prob, solver = "GUROBI"), "The solver GUROBI is not installed")
  }
})

test_that("Test a basic SOCP with GUROBI", {
  if("GUROBI" %in% installed_solvers()) {
    prob <- Problem(Minimize(p_norm(x,2) + 1.0), list(x == 0))
    result <- solve(prob, solver = "GUROBI")
    expect_equal(result$value, 1.0, tolerance = TOL)
    expect_equal(result$getValue(x), as.matrix(c(0, 0)), tolerance = TOL)
    
    # Example from
    # http://cvxopt.org/userguide/coneprog.html?highlight=solvers.lp#cvxopt.solvers.lp
    objective <- Minimize(-4*x[1] - 5*x[2])
    constraints <- list(2*x[1] + x[2] <= 3, (x[1] + 2*x[2])^2 <= 9, x[1] >= 0, x[2] >= 0)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "GUROBI")
    expect_equal(result$value, -9, tolerance = TOL)
    expect_equal(result$getValue(x), as.matrix(c(1, 1)), tolerance = TOL)
    
    # GUROBI's default lower bound for a decision variable is zero
    # This quick test ensures that the CVXR interface for GUROBI does *not* have that bound
    objective <- Minimize(x[1])
    constraints <- list(x[1] >= -100, x[1] <= -10, x[2] == 1)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "GUROBI")
    expect_equal(result$getValue(x), as.matrix(c(-100, 1)), tolerance = TOL)
    
    # Boolean and integer version.
    bool_var <- Variable(boolean = TRUE)
    int_var <- Variable(integer = TRUE)
    prob <- Problem(Minimize(p_norm(x,2)), list(x == bool_var, bool_var == 0))
    result <- solve(prob, solver = "GUROBI")
    expect_equal(result$value, 0, tolerance = TOL)
    expect_equal(result$getValue(bool_var), 0, tolerance = TOL)
    expect_equal(result$getValue(x), as.matrix(c(0, 0)), tolerance = TOL)
    
    # Example from
    # http://cvxopt.org/userguide/coneprog.html?highlight=solvers.lp#cvxopt.solvers.lp
    objective <- Minimize(-4*x[1] - 5*x[2])
    constraints <- list(2*x[1] + x[2] <= int_var, (x[1] + 2*x[2])^2 <= 9*bool_var, x[1] >= 0, x[2] >= 0, int_var == 3*bool_var, int_var == 3)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "GUROBI")
    expect_equal(result$value, -9, tolerance = TOL)
    expect_equal(result$getValue(int_var), 3, tolerance = TOL)
    expect_equal(result$getValue(bool_var), 1, tolerance = TOL)
    expect_equal(result$getValue(x), as.matrix(c(1,1)), tolerance = TOL)
  } else {
    prob <- Problem(Minimize(p_norm(x,1)), list(x == 0))
    expect_error(result <- solve(prob, solver = "GUROBI"), "The solver GUROBI is not installed")
  }
})

test_that("Make sure GUROBI's dual result matches other solvers", {
  if("GUROBI" %in% installed_solvers()) {
    constraints <- list(x == 0)
    prob <- Problem(Minimize(p_norm(x,1)))
    result <- solve(prob, solver = "GUROBI")
    duals_gurobi <- lapply(constraints, function(c) { result$getDualValue(c) })
    result <- solve(prob, solver = "ECOS")
    duals_ecos <- lapply(constraints, function(c) { result$getDualValue(c) })
    for(i in seq_along(constraints))
      expect_equal(duals_gurobi[[i]], duals_ecos[[i]], tolerance = TOL)
    
    # Example from
    # http://cvxopt.org/userguide/coneprog.html?highlight=solvers.lp#cvxopt.solvers.lp
    objective <- Minimize(-4*x[1] - 5*x[2])
    constraints <- list(2*x[1] + x[2] <= 3, x[1] + 2*x[2] <= 3, x[1] >= 0, x[2] >= 0)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "GUROBI")
    duals_gurobi <- lapply(constraints, function(c) { result$getDualValue(c) })
    result <- solve(prob, solver = "ECOS")
    duals_ecos <- lapply(constraints, function(c) { result$getDualValue(c) })
    for(i in seq_along(constraints))
      expect_equal(duals_gurobi[[i]], duals_ecos[[i]], tolerance = TOL)
  } else {
    prob <- Problem(Minimize(p_norm(x,1)), list(x == 0))
    expect_error(result <- solve(prob, solver = "GUROBI"), "The solver GUROBI is not installed")
  }
})

test_that("Test a basic LP with MOSEK", {
  if("MOSEK" %in% installed_solvers()) {
    prob <- Problem(Minimize(p_norm(x,1) + 1.0), list(x == 0))
    result <- solve(prob, solver = "MOSEK")
    expect_equal(result$value, 1.0, tolerance = TOL)
    expect_equal(result$getValue(x), as.matrix(c(0, 0)), tolerance = TOL)
    
    # Example from
    # http://cvxopt.org/userguide/coneprog.html?highlight=solvers.lp#cvxopt.solvers.lp
    objective <- Minimize(-4*x[1] - 5*x[2])
    constraints <- list(2*x[1] + x[2] <= 3, x[1] + 2*x[2] <= 3, x[1] >= 0, x[2] >= 0)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "MOSEK")
    expect_equal(result$value, -9, tolerance = TOL)
    expect_equal(result$getValue(x), as.matrix(c(1, 1)), tolerance = TOL)
    
    # MOSEK's default lower bound for a decision variable is zero
    # This quick test ensures that the cvxpy interface for MOSEK does *not* have that bound
    objective <- Minimize(x[1])
    constraints <- list(x[1] >= -100, x[1] <= -10, x[2] == 1)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "MOSEK")
    expect_equal(result$getValue(x), as.matrix(c(-100, 1)), tolerance = TOL)
  } else {
    prob <- Problem(Minimize(p_norm(x,1)), list(x == 0))
    expect_error(result <- solve(prob, solver = "MOSEK"), "The solver MOSEK is not installed")
  }
})

test_that("Test a basic SOCP with MOSEK", {
  if("MOSEK" %in% installed_solvers()) {
    prob <- Problem(Minimize(p_norm(x,2) + 1.0), list(x == 0))
    result <- solve(prob, solver = "MOSEK")
    expect_equal(result$value, 1.0, tolerance = TOL)
    expect_equal(result$getValue(x), as.matrix(c(0, 0)), tolerance = TOL)
    
    # Example from
    # http://cvxopt.org/userguide/coneprog.html?highlight=solvers.lp#cvxopt.solvers.lp
    objective <- Minimize(-4*x[1] - 5*x[2])
    constraints <- list(2*x[1] + x[2] <= 3, (x[1] + 2*x[2])^2 <= 9, x[1] >= 0, x[2] >= 0)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "MOSEK")
    expect_equal(result$value, -9, tolerance = TOL)
    expect_equal(result$getValue(x), as.matrix(c(1, 1)), tolerance = TOL)
    
    objective <- Minimize(x[1])
    constraints <- list(x[1] >= -100, x[1] <= -10, x[2] == 1)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "MOSEK")
    expect_equal(result$getValue(x), as.matrix(c(-100, 1)), tolerance = TOL)
  } else {
    prob <- Problem(Minimize(p_norm(x,1)), list(x == 0))
    expect_error(result <- solve(prob, solver = "MOSEK"), "The solver MOSEK is not installed")
  }
})

test_that("Make sure MOSEK's dual result matches other solvers", {
  if("MOSEK" %in% installed_solvers()) {
    constraints <- list(x == 0)
    prob <- Problem(Minimize(p_norm(x,1)))
    result <- solve(prob, solver = "MOSEK")
    duals_mosek <- lapply(constraints, function(c) { result$getDualValue(c) })
    result <- solve(prob, solver = "ECOS")
    duals_ecos <- lapply(constraints, function(c) { result$getDualValue(c) })
    for(i in seq_along(constraints))
      expect_equal(duals_mosek[[i]], duals_ecos[[i]], tolerance = TOL)
    
    # Example from
    # http://cvxopt.org/userguide/coneprog.html?highlight=solvers.lp#cvxopt.solvers.lp
    objective <- Minimize(-4*x[1] - 5*x[2])
    constraints <- list(2*x[1] + x[2] <= 3, x[1] + 2*x[2] <= 3, x[1] >= 0, x[2] >= 0)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "MOSEK")
    duals_mosek <- lapply(constraints, function(c) { result$getDualValue(c) })
    result <- solve(prob, solver = "ECOS")
    duals_ecos <- lapply(constraints, function(c) { result$getDualValue(c) })
    for(i in seq_along(constraints))
      expect_equal(duals_mosek[[i]], duals_ecos[[i]], tolerance = TOL)
  } else {
    prob <- Problem(Minimize(p_norm(x,1)), list(x == 0))
    expect_error(result <- solve(prob, solver = "MOSEK"), "The solver MOSEK is not installed")
  }
})

test_that("Test a basic SDP with MOSEK", {
  # TODO: Should work with PSD (>>, <<).
  if("MOSEK" %in% installed_solvers()) {
    # Test optimality gap for equilibration.
    n <- 3
    Art <- matrix(rnorm(n*n), nrow = n, ncol = n)
    
    t <- Variable()
    d <- Variable(n)
    D <- diag(d)
    constr <- list(Art %*% D %*% t(Art) - diag(n) == Variable(n, n, PSD = TRUE),
                   Variable(n, n, PSD = TRUE) == t*diag(n) - Art %*% D %*% t(Art), d >= 0)
    prob <- Problem(Minimize(t), constr)
    result <- solve(prob, solver = "MOSEK")
    expect_equal(result$status, "optimal")
  } else {
    prob <- Problem(Minimize(p_norm(x,1)), list(x == 0))
    expect_error(result <- solve(prob, solver = "MOSEK"), "The solver MOSEK is not installed")
  }
})

test_that("Test MOSEK parameters", {
  if("MOSEK" %in% installed_solvers()) {
    n <- 10
    m <- 4
    A <- matrix(rnorm(m*n), nrow = m, ncol = n)
    x <- matrix(rnorm(n), nrow = n, ncol = 1)
    y <- A %*% x
    
    # Solve a simple basis pursuit problem for testing purposes.
    z <- Variable(n)
    objective <- Minimize(norm1(z))
    constraints <- list(A %*% z == y)
    problem <- Problem(objective, constraints)
    expect_error(result <- solve(problem, solver = "MOSEK", dparam.basis_tol_x = "1e-8"))
    expect_error(result <- solve(problem, solver = "MOSEK", invalid_kwarg = NA))
    # solve(problem, solver = "MOSEK", mosek.dparam.basis_tol_x = 1e-8, MSK_IPAR_INTPNT_MAX_ITERATIONS = 20)
  } else {
    n <- 10
    m <- 4
    A <- matrix(rnorm(m*n), nrow = m, ncol = n)
    x <- matrix(rnorm(n), nrow = n, ncol = 1)
    y <- A %*% x
    
    # Solve a simple basis pursuit problem for testing purposes.
    z <- Variable(n)
    objective <- Minimize(norm1(z))
    constraints <- list(A %*% z == y)
    problem <- Problem(objective, constraints)
    expect_error(result <- solve(problem, solver = "MOSEK"), "The solver MOSEK is not installed")
  }
})

test_that("Test GUROBI warm start", {
  # Make sure that warm starting GUROBI behaves as expected.
  # Note: This only checks output, not whether or not GUROBI is warm starting internally.
  if("GUROBI" %in% installed_solvers()) {
    A <- Parameter(2, 2)
    b <- Parameter(2)
    h <- Parameter(2)
    c <- Parameter(2)
    
    value(A) <- rbind(c(1,0), c(0,0))
    value(b) <- c(1,0)
    value(h) <- c(2,2)
    value(c) <- c(1,1)
    
    objective <- Maximize(c[1]*x[1] + c[2]*x[2])
    constraints <- list(x[1] <= h[1],
                        x[2] <= h[2],
                        A %*% x == b)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "GUROBI", warm_start = TRUE)
    expect_equal(result$value, 3)
    expect_equal(result$getValue(x), matrix(c(1, 2)), tolerance = TOL)
    
    # Change A and b from the original values.
    value(A) <- rbind(c(0,0), c(0,1))   # <----- Changed.
    value(b) <- c(0,1)   # <----- Changed.
    value(h) <- c(2,2)
    value(c) <- c(1,1)
    
    # Without setting update_eq_constrs = FALSE, the results should change to the correct answer.
    objective <- Maximize(c[1]*x[1] + c[2]*x[2])
    constraints <- list(x[1] <= h[1],
                        x[2] <= h[2],
                        A %*% x == b)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "GUROBI", warm_start = TRUE)
    expect_equal(result$value, 3)
    expect_equal(result$getValue(x), matrix(c(2, 1)), tolerance = TOL)
    
    # Change h from the original values.
    value(A) <- rbind(c(1,0), c(0,0))
    value(b) <- c(1,0)
    value(h) <- c(1,1)   # <----- Changed.
    value(c) <- c(1,1)
    
    # Without setting update_eq_constrs = FALSE, the results should change to the correct answer.
    objective <- Maximize(c[1]*x[1] + c[2]*x[2])
    constraints <- list(x[1] <= h[1],
                        x[2] <= h[2],
                        A %*% x == b)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "GUROBI", warm_start = TRUE)
    expect_equal(result$value, 2)
    expect_equal(result$getValue(x), matrix(c(1, 1)), tolerance = TOL)
    
    # Change c from the original values.
    value(A) <- rbind(c(1,0), c(0,0))
    value(b) <- c(1,0)
    value(h) <- c(2,2)
    value(c) <- c(2,1)   # <----- Changed.
    
    # Without setting update_eq_constrs = FALSE, the results should change to the correct answer.
    objective <- Maximize(c[1]*x[1] + c[2]*x[2])
    constraints <- list(x[1] <= h[1],
                        x[2] <= h[2],
                        A %*% x == b)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "GUROBI", warm_start = TRUE)
    expect_equal(result$value, 4)
    expect_equal(result$getValue(x), matrix(c(1, 2)), tolerance = TOL)
  } else {
    prob <- Problem(Minimize(p_norm(x, 1) + 1.0), list(x == 0))
    expect_error(result <- solve(prob, solver = "GUROBI", warm_start = TRUE), "The solver GUROBI is not installed")
  }
})

test_that("Test a basic LP with XPRESS", {
  if("XPRESS" %in% installed_solvers()) {
    prob <- Problem(Minimize(p_norm(x,1) + 1.0), list(x == 0))
    result <- solve(prob, solver = "XPRESS")
    expect_equal(result$value, 1.0, tolerance = TOL)
    expect_equal(result$getValue(x), as.matrix(c(0, 0)), tolerance = TOL)
    
    # Example from
    # http://cvxopt.org/userguide/coneprog.html?highlight=solvers.lp#cvxopt.solvers.lp
    objective <- Minimize(-4*x[1] - 5*x[2])
    constraints <- list(2*x[1] + x[2] <= 3, x[1] + 2*x[2] <= 3, x[1] >= 0, x[2] >= 0)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "XPRESS")
    expect_equal(result$value, -9, tolerance = TOL)
    expect_equal(result$getValue(x), as.matrix(c(1, 1)), tolerance = TOL)
    
    # XPRESS's default lower bound for a decision variable is zero
    # This quick test ensures that the cvxpy interface for XPRESS does *not* have that bound
    objective <- Minimize(x[1])
    constraints <- list(x[1] >= -100, x[1] <= -10, x[2] == 1)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "MOSEK")
    expect_equal(result$getValue(x), as.matrix(c(-100, 1)), tolerance = TOL)
  } else {
    prob <- Problem(Minimize(p_norm(x,1)), list(x == 0))
    expect_error(result <- solve(prob, solver = "XPRESS"), "The solver XPRESS is not installed")
  }
})

test_that("Test a basic SOCP with XPRESS", {
  if("XPRESS" %in% installed_solvers()) {
    prob <- Problem(Minimize(p_norm(x,2) + 1.0), list(x == 0))
    result <- solve(prob, solver = "XPRESS")
    expect_equal(result$value, 1.0, tolerance = TOL)
    expect_equal(result$getValue(x), as.matrix(c(0, 0)), tolerance = TOL)
    
    # Example from
    # http://cvxopt.org/userguide/coneprog.html?highlight=solvers.lp#cvxopt.solvers.lp
    objective <- Minimize(-4*x[1] - 5*x[2])
    constraints <- list(2*x[1] + x[2] <= 3, (x[1] + 2*x[2])^2 <= 9, x[1] >= 0, x[2] >= 0)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "XPRESS")
    expect_equal(result$value, -9, tolerance = TOL)
    expect_equal(result$getValue(x), as.matrix(c(1, 1)), tolerance = TOL)
    
    objective <- Minimize(x[1])
    constraints <- list(x[1] >= -100, x[1] <= -10, x[2] == 1)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "XPRESS")
    expect_equal(result$getValue(x), as.matrix(c(-100, 1)), tolerance = TOL)
  } else {
    prob <- Problem(Minimize(p_norm(x,1)), list(x == 0))
    expect_error(result <- solve(prob, solver = "XPRESS"), "The solver XPRESS is not installed")
  }
})

test_that("Make sure XPRESS's dual result matches other solvers", {
  if("XPRESS" %in% installed_solvers()) {
    constraints <- list(x == 0)
    prob <- Problem(Minimize(p_norm(x,1)))
    result <- solve(prob, solver = "XPRESS")
    duals_mosek <- lapply(constraints, function(c) { result$getDualValue(c) })
    result <- solve(prob, solver = "ECOS")
    duals_ecos <- lapply(constraints, function(c) { result$getDualValue(c) })
    for(i in seq_along(constraints))
      expect_equal(duals_mosek[[i]], duals_ecos[[i]], tolerance = TOL)
    
    # Example from
    # http://cvxopt.org/userguide/coneprog.html?highlight=solvers.lp#cvxopt.solvers.lp
    objective <- Minimize(-4*x[1] - 5*x[2])
    constraints <- list(2*x[1] + x[2] <= 3, x[1] + 2*x[2] <= 3, x[1] >= 0, x[2] >= 0)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "XPRESS")
    duals_mosek <- lapply(constraints, function(c) { result$getDualValue(c) })
    result <- solve(prob, solver = "ECOS")
    duals_ecos <- lapply(constraints, function(c) { result$getDualValue(c) })
    for(i in seq_along(constraints))
      expect_equal(duals_mosek[[i]], duals_ecos[[i]], tolerance = TOL)
  } else {
    prob <- Problem(Minimize(p_norm(x,1)), list(x == 0))
    expect_error(result <- solve(prob, solver = "XPRESS"), "The solver XPRESS is not installed")
  }
})

test_that("Test a basic LP with NAG", {
  if("NAG" %in% installed_solvers()) {
    prob <- Problem(Minimize(p_norm(x,1) + 1.0), list(x == 0))
    result <- solve(prob, solver = "NAG")
    expect_equal(result$value, 1.0, tolerance = TOL)
    expect_equal(result$getValue(x), as.matrix(c(0, 0)), tolerance = TOL)
    
    # Example from
    # http://cvxopt.org/userguide/coneprog.html?highlight=solvers.lp#cvxopt.solvers.lp
    objective <- Minimize(-4*x[1] - 5*x[2])
    constraints <- list(2*x[1] + x[2] <= 3, x[1] + 2*x[2] <= 3, x[1] >= 0, x[2] >= 0)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "NAG")
    expect_equal(result$value, -9, tolerance = TOL)
    expect_equal(result$getValue(x), as.matrix(c(1, 1)), tolerance = TOL)
    
    # NAG's default lower bound for a decision variable is zero
    # This quick test ensures that the cvxpy interface for NAG does *not* have that bound
    objective <- Minimize(x[1])
    constraints <- list(x[1] >= -100, x[1] <= -10, x[2] == 1)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "NAG")
    expect_equal(result$getValue(x), as.matrix(c(-100, 1)), tolerance = TOL)
  } else {
    prob <- Problem(Minimize(p_norm(x,1)), list(x == 0))
    expect_error(result <- solve(prob, solver = "NAG"), "The solver NAG is not installed")
  }
})

test_that("Test a basic SOCP with NAG", {
  if("NAG" %in% installed_solvers()) {
    prob <- Problem(Minimize(p_norm(x,2) + 1.0), list(x == 0))
    result <- solve(prob, solver = "NAG")
    expect_equal(result$value, 1.0, tolerance = TOL)
    expect_equal(result$getValue(x), as.matrix(c(0, 0)), tolerance = TOL)
    
    # Example from
    # http://cvxopt.org/userguide/coneprog.html?highlight=solvers.lp#cvxopt.solvers.lp
    objective <- Minimize(-4*x[1] - 5*x[2])
    constraints <- list(2*x[1] + x[2] <= 3, (x[1] + 2*x[2])^2 <= 9, x[1] >= 0, x[2] >= 0)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "NAG")
    expect_equal(result$value, -9, tolerance = TOL)
    expect_equal(result$getValue(x), as.matrix(c(1, 1)), tolerance = TOL)
    
    objective <- Minimize(x[1])
    constraints <- list(x[1] >= -100, x[1] <= -10, x[2] == 1)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "NAG")
    expect_equal(result$getValue(x), as.matrix(c(-100, 1)), tolerance = TOL)
  } else {
    prob <- Problem(Minimize(p_norm(x,1)), list(x == 0))
    expect_error(result <- solve(prob, solver = "NAG"), "The solver NAG is not installed")
  }
})

test_that("Make sure NAG's dual result matches other solvers", {
  if("NAG" %in% installed_solvers()) {
    constraints <- list(x == 0)
    prob <- Problem(Minimize(p_norm(x,1)))
    result <- solve(prob, solver = "NAG")
    duals_mosek <- lapply(constraints, function(c) { result$getDualValue(c) })
    result <- solve(prob, solver = "ECOS")
    duals_ecos <- lapply(constraints, function(c) { result$getDualValue(c) })
    for(i in seq_along(constraints))
      expect_equal(duals_mosek[[i]], duals_ecos[[i]], tolerance = TOL)
    
    # Example from
    # http://cvxopt.org/userguide/coneprog.html?highlight=solvers.lp#cvxopt.solvers.lp
    objective <- Minimize(-4*x[1] - 5*x[2])
    constraints <- list(2*x[1] + x[2] <= 3, x[1] + 2*x[2] <= 3, x[1] >= 0, x[2] >= 0)
    prob <- Problem(objective, constraints)
    result <- solve(prob, solver = "NAG")
    duals_mosek <- lapply(constraints, function(c) { result$getDualValue(c) })
    result <- solve(prob, solver = "ECOS")
    duals_ecos <- lapply(constraints, function(c) { result$getDualValue(c) })
    for(i in seq_along(constraints))
      expect_equal(duals_mosek[[i]], duals_ecos[[i]], tolerance = TOL)
  } else {
    prob <- Problem(Minimize(p_norm(x,1)), list(x == 0))
    expect_error(result <- solve(prob, solver = "NAG"), "The solver NAG is not installed")
  }
})

test_that("Test the list of installed solvers", {
  prob <- Problem(Minimize(p_norm(x, 1) + 1.0), list(x == 0))
  for(solver in names(SOLVER_MAP_CONIC)) {
    if(solver %in% INSTALLED_SOLVERS) {
      result <- solve(prob, solver = solver)
      expect_equal(result$value, 1.0, tolerance = TOL)
      expect_equal(result$getValue(x), matrix(c(0, 0)), tolerance = TOL)
    } else
      expect_error(result <- solve(prob, solver = solver), paste("The solver", solver, "is not installed"))
  }
  
  for(solver in names(SOLVER_MAP_QP)) {
    if(solver %in% INSTALLED_SOLVERS) {
      result <- solve(prob, solver = solver)
      expect_equal(result$getValue(x), matrix(c(0, 0)), tolerance = TOL)
    } else
      expect_error(result <- solve(prob, solver = solver), paste("The solver", solver, "is not installed"))
  }
})
